\chapter{Contexts and Cooperation}

In Chapter~\ref{chap:textscreen}, EmbryOS learned to draw on a text screen. Now
we give it the illusion of doing several things at once. The idea is simple:
each \emph{process} owns its own stack and a small rectangle of the screen; the
kernel saves one process’s registers, restores another’s, and repeats. The
result is cooperative multitasking with a tiny, readable scheduler.

\section{Context Switching in 20 Lines}

A \emph{context switch} is just a swap of stack pointers plus the callee-saved
registers and \texttt{ra}. The assembly in Listing~\ref{lst:ctx_s} implements
two primitives:

\begin{itemize}
  \item \texttt{ctx\_switch(\&old\_sp, new\_sp)}: save current context, load another, return in the new one.
  \item \texttt{ctx\_start(\&save\_sp, new\_sp, entry)}: switch to a fresh stack and jump to \texttt{entry()}.
\end{itemize}

\noindent Their prototypes live in Listing~\ref{lst:ctx_h}.

\begin{figure}[H]
\centering
\lstinputlisting[style=oscode,language={[x86masm]Assembler},caption={Context switch, \texttt{ctx.s}},label={lst:ctx_s}]{../code/chapter3/ctx_short.s}
\end{figure}

\begin{figure}[H]
\centering
\lstinputlisting[style=oscode,language=C,caption={Context switch interface, \texttt{ctx.h}},label={lst:ctx_h}]{../code/chapter3/ctx.h}
\end{figure}

\section{A Page-Based “Heap” for Stacks}

We reserve a page-aligned region in the linker script and treat it as a pool of
4\,KiB \emph{frames}. A one-page free list is enough for stacks and small kernel
objects (Listing~\ref{lst:frame_c} and \ref{lst:frame_h}). The macro
\texttt{FRAME(T, i)} casts frame \texttt{i} to type \texttt{T}.

\begin{figure}[H]
\centering
\lstinputlisting[style=oscode,language=C,caption={Page allocator, \texttt{frame.c}},label={lst:frame_c}]{../code/chapter3/frame.c}
\end{figure}

\begin{figure}[H]
\centering
\lstinputlisting[style=oscode,language=C,caption={Page allocator interface, \texttt{frame.h}},label={lst:frame_h}]{../code/chapter3/frame.h}
\end{figure}

\section{Processes Own Windows}

Each process has a PCB with a saved stack pointer and a \texttt{rect} that
bounds where it may draw. Processes print using \texttt{proc\_put()}, which
converts local coordinates to global screen positions and clips to the
process’s rectangle (Listing~\ref{lst:process_h} and \ref{lst:process_c}).

\begin{figure}[H]
\centering
\lstinputlisting[style=oscode,language=C,caption={Process interface, \texttt{process.h}},label={lst:process_h}]{../code/chapter3/process.h}
\end{figure}

\begin{figure}[H]
\centering
\lstinputlisting[style=oscode,language=C,caption={Process management, \texttt{process.c}},label={lst:process_c}]{../code/chapter3/process.c}
\end{figure}

\section{Round-Robin in One Queue}

The scheduler maintains a single circular run queue. \texttt{sched\_yield()}
rotates the queue and switches from the current process to the next. New
processes are created with \texttt{sched\_run()}, which allocates a page,
enqueues the PCB, and \texttt{ctx\_start}s the entry function (Listing~\ref{lst:sched_h}
and \ref{lst:sched_c}).

\begin{figure}[H]
\centering
\lstinputlisting[style=oscode,language=C,caption={Scheduler interface, \texttt{sched.h}},label={lst:sched_h}]{../code/chapter3/sched.h}
\end{figure}

\begin{figure}[H]
\centering
\lstinputlisting[style=oscode,language=C,caption={Round-robin scheduler, \texttt{sched.c}},label={lst:sched_c}]{../code/chapter3/sched.c}
\end{figure}

\section{Demo: Four Windows, Two Letters}

The demo creates four processes, each confined to its window. Two run
\texttt{taskA} (a horizontal sweep of ‘A’), two run \texttt{taskB} (a vertical
sweep of ‘B’). The main loop simply yields repeatedly; preemption via timer
arrives in the next chapter. (Listing~\ref{lst:hello_c}.)

\begin{figure}[H]
\centering
\lstinputlisting[style=oscode,language=C,caption={Chapter 3 demo, \texttt{hello.c}},label={lst:hello_c}]{../code/chapter3/hello.c}
\end{figure}

\section*{Projects}

\begin{enumerate}
  \item \textbf{More processes.} Launch 6–8 processes; observe fairness.
  \item \textbf{Per-process clear.} Add \texttt{proc\_clear()} that fills only a process’s rectangle.
  \item \textbf{Priorities.} Add a second queue and demote the current process on each yield.
\end{enumerate}
