\chapter{Blocking I/O, Interrupts, and Sleep/Wake}
\label{chap:blocking-io}

In Chapter~\ref{chap:contexts} we built a preemptive kernel with priorities and a timer interrupt.
This chapter moves from polling to \emph{interrupt-driven, blocking I/O}. Concretely, we connect the
platform-level interrupt controller (PLIC) to the UART so that arriving input data can \emph{wake}
threads that are blocked waiting for characters. This requires a simple device driver, a safe
sleep/wake interface into the scheduler, and a bounded buffer to decouple device bursts from thread
consumers.

\section{Learning Goals}

\begin{itemize}
  \item Understand the role of the PLIC in claiming and completing external interrupts.
  \item Implement a UART receive path that uses interrupts instead of polling.
  \item Provide a blocking API \texttt{uart\_get()} that sleeps the calling thread and is later
        awakened by the device interrupt handler.
  \item Connect device ISRs to scheduler data structures (wait queues, run queues) safely.
\end{itemize}

\section{Big Picture}

The data path for receive (RX) is:
\begin{enumerate}
  \item The UART asserts an external interrupt when a byte arrives.
  \item The PLIC presents that interrupt to the hart; the trap handler \emph{claims} the interrupt ID.
  \item The kernel dispatches to the UART ISR, which drains the device RX FIFO into a ring buffer and
        moves threads waiting for input from a UART wait queue onto a run queue.
  \item Blocked callers of \texttt{uart\_get()} resume and consume bytes from the buffer.
\end{enumerate}

Two invariants are central:
\begin{itemize}
  \item If the buffer is non-empty, \texttt{uart\_get()} must not block.
  \item If new data arrive, then any threads waiting for input are eventually made runnable.
\end{itemize}

\section{PLIC Top-Half}
\label{sec:plic}

The PLIC collects, prioritizes, masks, and routes external interrupts to harts. The top-half logic
is minimal: read the \emph{claim/complete} register to obtain the pending interrupt ID, dispatch to
the corresponding ISR, then write the same ID back to \emph{complete} it so the source can re-assert
future interrupts. We program a non-zero priority for the UART interrupt, enable it for the hart,
and leave the threshold at~0 so all positive-priority interrupts are deliverable.

\lstinputlisting[
  style=oscode,
  language=C,
  caption={PLIC glue: claim, dispatch (UART), and completion, \texttt{plic.c}},
  label={lst:plic_c}
]{../code/chapter5/plic.c}

\lstinputlisting[
  style=oscode,
  language=C,
  caption={PLIC interface, \texttt{plic.h}},
  label={lst:plic_h}
]{../code/chapter5/plic.h}

\section{UART Driver (Bottom-Half)}
\label{sec:uart}

The UART driver exposes three routines:
\begin{itemize}
  \item \texttt{putchar(c)}: a polled transmit used for printing (busy-waits on TX not-full).
  \item \texttt{uart\_init()}: enables receive and the RX interrupt in the device.
  \item \texttt{uart\_get()}: a blocking call that returns the next received character.
\end{itemize}

Internally, the driver maintains:
\begin{itemize}
  \item a fixed-size ring buffer storing bytes drained by the ISR,
  \item a wait queue of PCBs sleeping for input.
\end{itemize}

The ISR runs in interrupt context. It repeatedly reads \texttt{rxdata} until the device indicates
“no byte available”, enqueues each received byte into the ring buffer (if not full), and finally
moves any sleepers from the UART wait queue to a CPU run queue so they can resume.

\lstinputlisting[
  style=oscode,
  language=C,
  caption={UART driver and ISR (receive path), \texttt{uart.c}},
  label={lst:uart_c}
]{../code/chapter5/uart.c}

\lstinputlisting[
  style=oscode,
  language=C,
  caption={UART interface, \texttt{uart.h}},
  label={lst:uart_h}
]{../code/chapter5/uart.h}

\section{Control Flow}

Putting the pieces together:
\begin{enumerate}
  \item \textbf{Initialization.} \texttt{plic\_init()} programs the UART interrupt priority/enable/
        threshold; \texttt{uart\_init()} turns on RX and RX interrupts in the device.
  \item \textbf{Blocking call.} A thread calls \texttt{uart\_get()}. If the buffer is empty, the
        thread is appended to the UART wait queue, marked blocked, and the scheduler runs another
        thread.
  \item \textbf{Interrupt.} When a byte arrives, the trap handler claims the UART interrupt and
        calls the UART ISR, which drains bytes into the ring buffer and enqueues all sleepers onto
        a run queue.
  \item \textbf{Resume.} Woken threads return from \texttt{uart\_get()} with available bytes.
\end{enumerate}

\section{Demonstration: Multitasking and Interrupts}

The following demonstration program, \texttt{hello.c}, combines timer interrupts, the scheduler,
and UART initialization to show multiple concurrent tasks updating regions of the display.
Each task repeatedly writes characters to its own rectangle, yielding on timer interrupts.
The UART driver remains active and interrupt-driven while the tasks run.

\lstinputlisting[
  style=oscode,
  language=C,
  caption={Multitasking demo using timer and UART, \texttt{hello.c}},
  label={lst:hello_c}
]{../code/chapter5/hello.c}

\section{Correctness and Common Pitfalls}

\paragraph{Completing interrupts.}
Always write the claimed ID back to the PLIC claim/complete register after servicing; otherwise the
source remains in-service and further interrupts will not be delivered.

\paragraph{Wake semantics.}
A simple policy is to wake all sleepers whenever new data arrive. This is easy to reason about, but
may cause extra context switches if many threads compete for few bytes. An optimization (left as an
exercise) is to wake exactly $N$ sleepers when $N$ new bytes were enqueued.

\paragraph{Bounded ISR time.}
The ISR drains the RX FIFO until the device reports “no data”; this bounds the interrupt work while
avoiding livelock under bursts.

\section*{Projects}

\begin{enumerate}
  \item \textbf{Wake-$N$ policy.} Modify the ISR to wake exactly as many sleepers as bytes enqueued.
        Compare context-switch counts with the “wake-all” baseline.
  \item \textbf{Non-blocking variant.} Add \texttt{int uart\_tryget(void)} that returns \texttt{-1}
        if the buffer is empty without blocking.
  \item \textbf{Interrupt masking.} Add an API to temporarily disable UART RX interrupts in the
        device while keeping PLIC enablement; show that \texttt{uart\_get()} still works via polling.
  \item \textbf{Proof sketch.} Argue that \texttt{uart\_get()} does not deadlock assuming interrupts
        are eventually delivered and the scheduler is fair.
\end{enumerate}
