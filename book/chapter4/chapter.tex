\chapter{Preemption and Priorities}

In Chapter~\ref{chap:contexts} we built a cooperative scheduler: processes
called \texttt{sched\_yield()} voluntarily.  This chapter connects EmbryOS to
hardware interrupts so that the system can take the CPU away from a running
process automatically.  We also add priorities: interactive processes at level~0,
background work at level~1, and the main loop at level~2.  Level~2 runs only
when nothing else is runnable.

\section{Trap Entry and Exit}

Every trap—interrupt or exception—enters at the same assembly label,
\texttt{\_trap\_handler}.  The CPU switches to machine mode, disables further
interrupts, and jumps to the address stored in \texttt{mtvec}.  The handler in
Listing~\ref{lst:trap_s} saves all integer registers on the current stack,
calls the C function \texttt{software\_trap\_handler()}, and finally restores
registers and returns with \texttt{mret}.  Because all state is preserved, C
code can safely run inside the handler.

\begin{figure}[H]
\centering
\lstinputlisting[
  style=oscode,
  language={[x86masm]Assembler},
  caption={Unified trap entry and exit, \texttt{trap.s}},
  label={lst:trap_s}
]{../code/chapter4/trap_short.s}
\end{figure}

\section{Generalized Interrupt Handling}

EmbryOS decodes all interrupts and exceptions in one place:
\texttt{software\_trap\_handler()} (Listing~\ref{lst:interrupt_c}).
Each interrupt type has an entry in a small table of C function pointers.
\texttt{intr\_init()} installs \texttt{\_trap\_handler} in \texttt{mtvec},
\texttt{intr\_set\_handler()} registers individual handlers, and
\texttt{intr\_enable()} or \texttt{intr\_disable()} control the global
\texttt{mstatus.MIE} bit.  The handler in this chapter is used for the timer,
but later chapters will reuse the same interface for system calls and devices.

\begin{figure}[H]
\centering
\lstinputlisting[
  style=oscode,
  language=C,
  caption={Generic interrupt dispatcher, \texttt{interrupt.c}},
  label={lst:interrupt_c}
]{../code/chapter4/interrupt.c}
\end{figure}

\begin{figure}[H]
\centering
\lstinputlisting[
  style=oscode,
  language=C,
  caption={Interrupt interface, \texttt{interrupt.h}},
  label={lst:interrupt_h}
]{../code/chapter4/interrupt.h}
\end{figure}

\section{The Machine Timer}

The RISC-V machine timer consists of two 64-bit registers in the CLINT region:
\texttt{mtime}, a free-running counter, and \texttt{mtimecmp}, which raises an
interrupt when the counter reaches its value.  Listing~\ref{lst:mtime_c} shows
how EmbryOS enables timer interrupts (\texttt{mie.MTIE}) and re-arms the timer
each time it fires.

\begin{figure}[H]
\centering
\lstinputlisting[
  style=oscode,
  language=C,
  caption={Machine timer driver, \texttt{mtime.c}},
  label={lst:mtime_c}
]{../code/chapter4/mtime.c}
\end{figure}

\begin{figure}[H]
\centering
\lstinputlisting[
  style=oscode,
  language=C,
  caption={Timer interface, \texttt{mtime.h}},
  label={lst:mtime_h}
]{../code/chapter4/mtime.h}
\end{figure}

\section{Priorities and Preemption}

The scheduler now maintains three run queues.  Priority~0 is for
\emph{interactive} tasks such as user-facing animation or input handlers.
Priority~1 is for \emph{background} work that can run when the system is idle.
Priority~2 contains only the \emph{main loop}, which simply waits for
interrupts and runs when nothing else is ready.

Each timer interrupt calls \texttt{sched\_yield()}, which rotates the run
queues.  Interactive tasks that use their entire quantum are demoted to level~1,
while background processes and the main loop remain at their assigned levels.
This yields a simple, realistic priority policy that still fits on one page.

\begin{figure}[H]
\centering
\lstinputlisting[
  style=oscode,
  language=C,
  caption={Priority scheduler, \texttt{sched.c}},
  label={lst:sched_c}
]{../code/chapter4/sched.c}
\end{figure}

\begin{figure}[H]
\centering
\lstinputlisting[
  style=oscode,
  language=C,
  caption={Scheduler interface, \texttt{sched.h}},
  label={lst:sched_h}
]{../code/chapter4/sched.h}
\end{figure}

\section{Demonstration: Timed Preemption}

The demo (Listing~\ref{lst:hello_c}) installs the timer interrupt and creates
four copies of \texttt{taskA()}, each drawing letters in its own window.
None of them ever call \texttt{sched\_yield()}; preemption is handled entirely
by the timer.  The main process runs at priority~2, sleeping in a
\texttt{wfi} loop until all other processes are idle.

\begin{figure}[H]
\centering
\lstinputlisting[
  style=oscode,
  language=C,
  caption={Preemptive demo with three priority levels, \texttt{hello.c}},
  label={lst:hello_c}
]{../code/chapter4/hello.c}
\end{figure}

\section*{Projects}

\begin{enumerate}
  \item \textbf{More interrupt types.} Extend \texttt{interrupt.c} with a
        keyboard or software interrupt handler.
  \item \textbf{Dynamic priorities.} Allow processes to raise or lower their
        priority based on activity.
  \item \textbf{Timer frequency.} Change the quantum in
        \texttt{hello.c} and observe how it affects responsiveness.
\end{enumerate}
