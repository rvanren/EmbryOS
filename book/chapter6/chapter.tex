\chapter{Process Termination and Cleanup}
\label{chap:termination}

In Chapter~\ref{chap:blocking-io}, our kernel gained interrupts, blocking I/O,
and preemptive scheduling.  However, once created, processes would run forever:
there was no way to terminate a process or reclaim its resources.
In this chapter we add safe process termination and automatic cleanup,
so that the system can start and stop processes dynamically.

\section{Learning Goals}

\begin{itemize}
  \item Understand why a process cannot safely free its own stack.
  \item Implement process termination without memory leaks.
  \item Integrate cleanup into the regular scheduling cycle.
  \item Demonstrate a simple interactive system that can create and end tasks.
\end{itemize}

\section{Motivation}

A running process occupies a kernel stack and a Process Control Block (PCB),
both allocated from the kernel’s frame allocator.  If a process simply returns
from its main function, the kernel would still be executing on its own stack,
so freeing that memory immediately would destroy the very stack currently in
use.  The kernel therefore needs a mechanism for a process to
\emph{mark itself as terminated}, switch to another process, and allow the new
process to clean up the old one safely.

\section{Design Overview}

Our solution divides the work into two small routines:
\begin{itemize}
  \item \texttt{proc\_exit()}~— called by a process to remove itself from the
        run queue and mark its PCB for deletion.
  \item \texttt{proc\_reap\_zombies()}~— called after every context switch to
        free PCBs that have been marked as terminated.
\end{itemize}

When a process exits, it adds itself to a global list of “zombie” PCBs and calls
\texttt{sched\_block()} to switch to another process.  After the switch, the new
process executes on its own stack and can safely free any zombies that were left
behind.

\begin{figure}[H]
\centering
\lstinputlisting[
  style=oscode,
  language=C,
  caption={Process termination and cleanup, \texttt{proc\_clean.c}},
  label={lst:proc_clean}
]{../code/chapter6/proc_clean.c}
\end{figure}

\section{Integration with the Scheduler}

The scheduler now calls \texttt{proc\_reap\_zombies()} after every context
switch, ensuring that terminated processes are always reclaimed promptly,
even in systems that never become idle.

\begin{figure}[H]
\centering
\lstinputlisting[
  style=oscode,
  language=C,
  caption={Scheduler with integrated cleanup, \texttt{sched.c}},
  label={lst:sched_c}
]{../code/chapter6/sched.c}
\end{figure}

\section{Demonstration Program}

The updated demonstration program, shown below, now allows processes to
terminate and new ones to be created dynamically.  The function
\texttt{taskB()} waits for keyboard input; when you type an exclamation mark~(!),
it spawns a new instance of \texttt{taskA()}, and when you type a period~(.),
it calls \texttt{proc\_exit()} to terminate itself.

This marks the first step toward a command shell: user input can now launch
and end programs interactively.

\begin{figure}[H]
\centering
\lstinputlisting[
  style=oscode,
  language=C,
  caption={Interactive demonstration with process creation and termination, \texttt{hello.c}},
  label={lst:hello_c}
]{../code/chapter6/hello.c}
\end{figure}

\section{Discussion}

\paragraph{Safety.}
A process never frees its own stack; cleanup happens only after a context switch
to another stack.  This guarantees that no code executes on freed memory.

\paragraph{Progress.}
Because cleanup occurs after every switch, memory is reclaimed even when the
system is busy and never idles.

\paragraph{Toward a shell.}
Dynamic process creation and termination provide the essential building blocks
for a shell or command interpreter, where input can start new processes and
existing processes can exit.

\section*{Projects}

\begin{enumerate}
  \item Extend the system with a \texttt{join()} function that allows one
        process to wait for another to finish.
  \item Add a \texttt{kill()} function that removes another process from its
        run queue asynchronously.
  \item Modify the demo to track the number of running processes and display it
        in the corner of the screen.
\end{enumerate}
