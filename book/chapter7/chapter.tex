\chapter{User Mode and System Calls}

This chapter introduces \textbf{User mode} and a minimal \textbf{system call interface} while intentionally keeping the execution model simple: we reuse the same stack for both kernel and user code.  This provides a smooth conceptual transition from Chapter~6 (kernel threads only) to Chapter~8 (full user stacks, register hygiene, and trap stack swapping).

\section{Goals}

\begin{itemize}
  \item Enter \textbf{U-mode} from the kernel using a tiny \texttt{enter\_user()} stub.
  \item Provide a \textbf{system call ABI} using \texttt{ecall}, with arguments in \texttt{a0..a4} and the syscall number in \texttt{a7}.
  \item Offer a small \textbf{user library} (\texttt{syslib.h}) so user code can call \texttt{user\_put}, \texttt{user\_get}, \texttt{user\_spawn}, and \texttt{user\_exit}.
  \item Keep the model deliberately simple: the kernel and user share the same stack in this chapter.
\end{itemize}

In Chapter~8 we will expand this entry path to set up a separate user stack, clear registers before entering U-mode, and use \texttt{mscratch} to switch to a per-process kernel stack during traps.

\section{Entering User Mode}

We replace the one-off \texttt{ctx\_start} from earlier chapters with a minimal, reusable \texttt{enter\_user()} routine.  It loads the user entry point into \texttt{mepc}, clears \texttt{mstatus.MPP} to select U-mode, and executes \texttt{mret}.  There is no stack change yet.

\begin{figure}[H]
\centering
\lstinputlisting[language={[x86masm]Assembler},
  caption={Minimal user entry stub: reuse the current stack; switch privilege only.},
  label={fig:enter_user}]{../code/chapter7/enter_user.s}
\end{figure}

For convenience, we also include a \texttt{user\_setup()} helper here that (for now) configures a permissive PMP region so U-mode can execute without faults.  It is intentionally broad and will be tightened in Chapter~9 when we add true isolation.

\section{System Call ABI}

System calls use the RISC-V \texttt{ecall} instruction:

\begin{itemize}
  \item \textbf{Number} in \texttt{a7}
  \item \textbf{Arguments} in \texttt{a0..a4}
  \item \textbf{Return value} in \texttt{a0}
\end{itemize}

We define four calls for this chapter:

\begin{center}
\begin{tabular}{lll}
\toprule
Name & Number & Purpose \\
\midrule
\texttt{SYS\_EXIT}  & 0 & Terminate the current process \\
\texttt{SYS\_SPAWN} & 1 & Start a new process from the app table \\
\texttt{SYS\_GET}   & 2 & Get a character from UART (blocking) \\
\texttt{SYS\_PUT}   & 3 & Draw a character onto the process window \\
\bottomrule
\end{tabular}
\end{center}

\begin{figure}[H]
\centering
\lstinputlisting[language=C,
  caption={System call numbers and handler signature.},
  label={fig:syscall_h}]{../code/chapter7/syscall.h}
\end{figure}

The kernel’s syscall handler reads \texttt{a7} to branch to the appropriate operation, grabs arguments from \texttt{a0..a4}, writes a return value back to \texttt{a0} when needed, and returns to U-mode through the regular trap return path.

\begin{figure}[H]
\centering
\lstinputlisting[language=C,
  caption={Kernel syscall handler.},
  label={fig:syscall_c}]{../code/chapter7/syscall.c}
\end{figure}

\section{User-side Convenience Wrappers}

To make user code pleasant to write, \texttt{syslib.h} provides thin inline wrappers that load registers and issue \texttt{ecall}.  This keeps user code in~C while preserving a precise ABI.

\begin{figure}[H]
\centering
\lstinputlisting[language=C,
  caption={User library: syscall wrappers.},
  label={fig:syslib_h}]{../code/chapter7/syslib.h}
\end{figure}

\section{Demo Applications}

For this chapter, “applications” are simply functions compiled with the kernel that we jump into via \texttt{enter\_user()}.  They remain PIC-agnostic here (we are still sharing the kernel stack); full PIC loading arrives in Chapter~8.

\begin{itemize}
  \item \texttt{codeA}: animated letters that wander and repaint.
  \item \texttt{codeB}: reads keyboard input and echoes it into its window.  Typing \texttt{!} spawns another app instance; typing \texttt{.} exits.
\end{itemize}

\begin{figure}[H]
\centering
\lstinputlisting[language=C,
  caption={Application table and two demo apps.},
  label={fig:apps_c}]{../code/chapter7/apps.c}
\end{figure}

Each entry point (\texttt{taskA}, \texttt{taskB}) calls \texttt{enter\_user()} with the user function symbol.  There is no user stack yet; this step changes privilege first and keeps stack management for later.

\section{Kernel Setup and Scheduling}

\texttt{main()} initializes memory, interrupts, UART, and the timer, installs the syscall handler, calls \texttt{user\_setup()} (permissive PMP for now), and then schedules a few app instances into non-overlapping windows.  The scheduler stays preemptive as in Chapter~6, but now tasks run in U-mode.

\begin{figure}[H]
\centering
\lstinputlisting[language=C,
  caption={Kernel initialization and launching demo apps.},
  label={fig:hello_c}]{../code/chapter7/hello.c}
\end{figure}

\subsection*{Timer Quantum}

We use a 50~ms quantum (\texttt{mtime\_reset(QUANTUM)} in the timer ISR) to time-slice between runnable user tasks.  Preemption is unchanged from Chapter~6, but now tasks execute in user mode.

\section{What to Expect When Running}

\begin{itemize}
  \item One app animates characters (\texttt{codeA}); another echoes keyboard input (\texttt{codeB}) in a separate screen region.
  \item Typing \texttt{!} in the input window spawns a new process (another app instance).
  \item Typing \texttt{.} exits that process (\texttt{SYS\_EXIT}).
\end{itemize}

If you disassemble the kernel, you’ll see that \texttt{enter\_user()} performs exactly three operations: set \texttt{mepc}, clear \texttt{mstatus.MPP}, and \texttt{mret}.  That’s the entire privilege switch for now.

\section{Design Notes and Forward Path}

\begin{itemize}
  \item \textbf{Why same stack?}  This keeps Chapter~7 focused on the privilege model and the syscall ABI without introducing the complexity of dual stacks or register sanitization.
  \item \textbf{Why the permissive PMP in \texttt{user\_setup}?}  It ensures U-mode can run without permission faults while we are still sharing stacks and kernel text/data.  In Chapter~9 we will apply real PMP isolation that restricts each process to its code+data page and its stack page.
  \item \textbf{Next:}  In Chapter~8 we will add:
    \begin{enumerate}
      \item a separate user stack,
      \item register clearing before \texttt{mret},
      \item use of \texttt{mscratch} for per-process kernel stacks during traps,
      \item and support for position-independent user binaries.
    \end{enumerate}
\end{itemize}

With these additions, the system calls and scheduling logic from this chapter continue to work unchanged; we just harden the boundary and the calling convention.
