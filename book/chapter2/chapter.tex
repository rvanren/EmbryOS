\chapter{Seeing Is Believing}

In Chapter~1 we learned to send characters to the UART.  In this chapter we
build a small \texttt{screen} library that treats the terminal as a logical
80$\times$24 grid of colored cells.  Using this abstraction we can animate a
banner and, for the first time, \emph{see} EmbryOS doing something dynamic.

\section{A Minimal Screen Abstraction}

The \texttt{screen} library provides three functions:
\begin{itemize}
  \item \texttt{screen\_move(row, col)} --- move the cursor to a specific
        position on the logical screen;
  \item \texttt{screen\_put(ch, color)} --- draw one printable character in the
        given color and advance the cursor;
  \item \texttt{screen\_clear(x, y, w, h)} --- fill rectangle with spaces.
\end{itemize}
The header \texttt{screen.h} defines these prototypes together with constants
for the screen size.

\begin{figure}[H]
\centering
\begin{minipage}{0.7\textwidth}
\lstinputlisting[
  style=oscode,
  language=C,
  caption={Header file \texttt{screen.h}},
  label={lst:screen_h}
]{../code/chapter2/screen.h}
\end{minipage}
\end{figure}

\section{Implementing the Screen Library}

Internally, the library translates screen coordinates into ANSI escape sequences
understood by the terminal.  Each call to \texttt{screen\_put()} prints exactly
one character, optionally changing its color.

\begin{figure}[H]
\centering
\begin{minipage}{0.9\textwidth}
\lstinputlisting[
  style=oscode,
  language=C,
  caption={Implementation of the logical screen in \texttt{screen.c}},
  label={lst:screen_c}
]{../code/chapter2/screen.c}
\end{minipage}
\end{figure}

The cursor position \texttt{(cur\_row, cur\_col)} is tracked in software so that
later we can implement off-screen buffers or multiple windows without changing
the interface.

\section{Formatted Output}

Our \texttt{stdio} module from Chapter~1 is extended with a simple
\texttt{printf()} that understands \texttt{\%d}, \texttt{\%x}, \texttt{\%s},
and \texttt{\%c}.  The implementation uses the standard C mechanism for
variable argument lists (\texttt{<stdarg.h>}) but does not rely on any external
libraries.

\begin{figure}[H]
\centering
\begin{minipage}{0.9\textwidth}
\lstinputlisting[
  style=oscode,
  language=C,
  caption={Minimal \texttt{printf()} implementation in \texttt{stdio.c}},
  label={lst:stdio_c}
]{../code/chapter2/stdio.c}
\end{minipage}
\end{figure}

\section{The Animated Banner}

The program in Listing~\ref{lst:hello_c} displays a continuously scrolling,
colored banner using the new screen abstraction.  Each frame rewrites only the
row that contains the banner, giving the impression of smooth motion.

\begin{figure}[H]
\centering
\begin{minipage}{0.9\textwidth}
\lstinputlisting[
  style=oscode,
  language=C,
  caption={Animated banner using the logical screen},
  label={lst:hello_c}
]{../code/chapter2/hello.c}
\end{minipage}
\end{figure}

When run under QEMU with \texttt{-nographic}, the terminal itself acts as a
display: the colored text moves left across the screen, wraps around, and
continues indefinitely.

\section{Projects}

\begin{enumerate}
  \item \textbf{Double banner.}
        Draw two independent rows of text scrolling at different speeds or
        colors.  How would you manage two cursors?
  \item \textbf{Screen buffer.}
        Replace \texttt{screen\_clear()} with a memory array representing all
        characters.  Update only cells that change.
\end{enumerate}
