\chapter{Seeing is Believing}

In the previous chapter we printed \texttt{"Hello, World"} through the UART.  
Now we use that same UART to draw to a \emph{screen}: the terminal connected to QEMU or your board’s serial port.  
By sending ANSI escape sequences, we can move the cursor, set colors, and print text anywhere.  
This provides a simple 80\,$\times$\,24 text display we can treat as a “frame buffer.”

We also refactor the structure: all platform-dependent constants move into \texttt{platform.h},  
the UART access routines into \texttt{uart.c/h}, and the new “screen” layer builds on top.

\section*{Platform parameters}

Hardware constants live in \texttt{platform.h}.  
For now we only define the UART base address, but this file will later include the CLINT and PLIC bases.

\begin{figure}[htb]
\centering
\lstinputlisting[style=oscode,language=C,
  caption={\texttt{platform.h}: board-specific constants.},
  label={lst-platform-h}]{../code/chapter2/platform.h}
\end{figure}

\paragraph{Portability.}
Changing to a different QEMU machine or board requires editing only this file.

\paragraph{Unsigned literals.}
The \texttt{UL} suffix marks constants as unsigned, avoiding sign extension on 64-bit compilers.

\section*{UART driver}

The UART (Universal Asynchronous Receiver/Transmitter) presents memory-mapped registers for transmit and receive.  
We only use transmit for now.

\begin{figure}[htb]
\centering
\lstinputlisting[style=oscode,language=C,
  caption={\texttt{uart.h}: interface for UART I/O.},
  label={lst-uart-h}]{../code/chapter2/uart.h}
\end{figure}

\begin{figure}[htb]
\centering
\lstinputlisting[style=oscode,language=C,
  caption={\texttt{uart.c}: minimal transmit path.},
  label={lst-uart-c}]{../code/chapter2/uart.c}
\end{figure}

\noindent
The driver waits until the transmit FIFO is not full, then writes one byte to \texttt{txdata}.  
All registers are declared \texttt{volatile} so the compiler never reorders MMIO operations.

\section*{Minimal \texttt{printf}}

To print formatted text conveniently, we layer a tiny \texttt{printf} on top of the UART.

\begin{figure}[htb]
\centering
\lstinputlisting[style=oscode,language=C,
  caption={\texttt{stdio.h}: prototypes for formatted output.},
  label={lst-stdio-h}]{../code/chapter2/stdio.h}
\end{figure}

\begin{figure}[htb]
\centering
\lstinputlisting[style=oscode,language=C,
  caption={\texttt{stdio.c}: a minimal \texttt{printf}.},
  label={lst-stdio-c}]{../code/chapter2/stdio.c}
\end{figure}

\section*{Text screen}

We treat the terminal as an 80\,$\times$\,24 grid.  
Each function in \texttt{screen.c} emits ANSI escape sequences to move the cursor and set colors.

\begin{figure}[htb]
\centering
\lstinputlisting[style=oscode,language=C,
  caption={\texttt{screen.h}: screen API.},
  label={lst-screen-h}]{../code/chapter2/screen.h}
\end{figure}

\begin{figure}[htb]
\centering
\lstinputlisting[style=oscode,language=C,
  caption={\texttt{screen.c}: ANSI-based text rendering.},
  label={lst-screen-c}]{../code/chapter2/screen.c}
\end{figure}

\noindent
Escape sequences such as \verb|\033[<r>;<c>H| move the cursor,
and \verb|\033[3<f>m| or \verb|\033[4<b>m| set the foreground and background colors.
We use the eight basic ANSI colors (\texttt{0..7}).

\section*{Demo program}

The application animates a banner that scrolls horizontally across the middle row, cycling colors as it moves.

\begin{figure}[htb]
\centering
\lstinputlisting[style=oscode,language=C,
  caption={\texttt{hello.c}: scrolling banner demo.},
  label={lst-hello-c}]{../code/chapter2/hello.c}
\end{figure}

\paragraph{Behavior.}
\begin{itemize}
  \item The banner wraps horizontally for a continuous scroll.
  \item Colors cycle through the eight ANSI basic colors.
  \item Timing is provided by a simple busy-wait loop.
\end{itemize}

\section*{Building and running}

Use the same \texttt{Makefile} structure as in Chapter 1:

\begin{verbatim}
qemu-system-riscv32 -machine sifive_u -nographic \
  -bios none -kernel hello.elf
\end{verbatim}

If you use the \texttt{virt} machine, set \texttt{UART\_BASE} in \texttt{platform.h}
to \texttt{0x10000000UL} instead.  
In Docker, detach from QEMU with \texttt{Ctrl-P Ctrl-Q} and stop the container from the host when done.

\section*{Projects}

\begin{enumerate}
  \item \textbf{Color stripes.} Fill each row with a different background color.
  \item \textbf{Box drawing.} Draw a filled 20\,$\times$\,5 rectangle at row 10, column 30.
  \item \textbf{Wraparound scroll.} Make the banner wrap seamlessly around the edges.
  \item \textbf{Blinking cursor.} Add a blinking colored cursor.
  \item \textbf{Port test.} Change \texttt{UART\_BASE} for a different QEMU machine and confirm output.
\end{enumerate}
