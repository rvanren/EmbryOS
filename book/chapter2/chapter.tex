\chapter{Writing to the Screen (Text Mode)}
\label{chap:textscreen}

In the previous chapter, we learned how to send characters through the UART.
In this one, we will use the very same device to \emph{draw} on a screen—our
terminal window—by taking advantage of ANSI escape codes.  No new hardware
drivers are required, and everything works even when running inside Docker.

\section{The Terminal as a Screen}

Although our current output device is just a UART, the terminal emulator on the
host interprets special sequences of characters that start with the \texttt{ESC}
(``\textbackslash033'') character.  These \emph{escape sequences} tell the
terminal to move the cursor, clear parts of the screen, or change text color.

We can think of this as a very simple display: each position on the screen
corresponds to a character cell, and the terminal remembers what was printed
there.  Instead of manipulating pixels, we manipulate characters.

\section{Useful Escape Sequences}

\begin{table}[h]
  \centering
  \begin{tabular}{ll}
    \toprule
    Sequence & Effect \\
    \midrule
    \texttt{\textbackslash033[2J} & Clear the entire screen \\
    \texttt{\textbackslash033[H}  & Move cursor to top--left corner \\
    \texttt{\textbackslash033[row;colH} & Move cursor to position \texttt{(row,col)} \\
    \texttt{\textbackslash033[3\emph{n}m} & Set text color (\emph{n}=0..7) \\
    \texttt{\textbackslash033[0m} & Reset attributes \\
    \bottomrule
  \end{tabular}
  \caption{A few common ANSI escape sequences.}
\end{table}

\section{Our First Text-Mode Library}

Create a file \texttt{screen.c} with the following helper functions:

\begin{lstlisting}[style=oscode,language=C,caption={Minimal text-mode screen library},label={lst:screen_c}]
#define ESC "\033"

void clear_screen(void) {
    printf(ESC "[2J");       // clear screen
    printf(ESC "[H");        // move cursor home
}

void move_cursor(int row, int col) {
    printf(ESC "[%d;%dH", row, col);
}

void set_color(int color) {
    printf(ESC "[3%dm", color);  // 0=black ... 7=white
}
\end{lstlisting}

\noindent
These simply print special character sequences.  The terminal interprets them
as commands rather than text.

\section{A Simple Demo}

Let us use these helpers in \texttt{hello.c}:

\begin{lstlisting}[style=oscode,language=C,caption={Colored "Hello" in text mode},label={lst:hello_text}]
int main(void) {
    clear_screen();
    for (int i = 0; i < 6; i++) {
        set_color(i + 1);
        move_cursor(2 + i, 10);
        printf("EmbryOS says hello!\n");
    }
    set_color(7);
    move_cursor(10, 0);
    printf("\n");
    return 0;
}
\end{lstlisting}

Recompile and run:
\begin{verbatim}
$ make qemu
\end{verbatim}

If your terminal supports color (most do), you should see the message appear in
a rainbow pattern down the left side of the screen.

\section{Toolbox: ANSI Escape Codes}

Escape codes date back to the early 1970s.  They were designed for the DEC
VT100 terminal and remain a universal standard today.  Modern Linux, macOS,
and Windows terminals all recognize them.

They provide a convenient, device-independent way to control the layout of
text.  For embedded or bare-metal systems, they are invaluable because they
require no additional hardware—only a serial output.

\section*{Projects}

\begin{enumerate}
  \item \textbf{Screen clear animation.}
  Write a program that fills the screen with `*` characters one row at a time,
  pausing briefly between rows.  Hint: you will need a delay loop.
  \item \textbf{Progress bar.}
  Print a single line of text that gradually fills with `#` characters to
  simulate progress.  Use \texttt{move\_cursor()} to update in place.
  \item \textbf{Color cycling.}
  Print “Hello World” repeatedly, changing colors every iteration.
  \item \textbf{Bonus:}
  Combine all of the above into a short “boot animation” for EmbryOS.
\end{enumerate}
