\chapter{Hello, World}

We begin by building the smallest possible operating system: one that simply prints
\texttt{"Hello, World"} through the UART.  
This chapter introduces the build environment, linker script, and a first taste of C and assembly in the RISC-V setting.

\section*{Project layout}

Each chapter has its own directory under \texttt{code/}.  
For example, Chapter 1’s code lives in \texttt{code/chapter1/} and builds with a simple \texttt{Makefile}.  
The resulting binary can run both in QEMU and, later, on real RISC-V hardware.

\section*{Docker build environment}

We use Docker to keep the environment identical across hosts.  
The Docker image installs a RISC-V cross-compiler and QEMU.

\begin{figure}[htb]
\centering
\lstinputlisting[style=oscode,language={},
  caption={\texttt{Dockerfile}: build and run environment for EmbryOS.},
  label={lst-dockerfile}]{../code/Dockerfile}
\end{figure}

Once built, run an interactive shell inside the container:
\begin{verbatim}
docker build -t embryos .
docker run -it --rm embryos
\end{verbatim}

\section*{Makefile}

The \texttt{Makefile} compiles both assembly and C, links them with a minimal linker script, and
launches QEMU.  
To quit QEMU’s terminal, press \texttt{Ctrl-A} followed by \texttt{x}.

\begin{figure}[htb]
\centering
\lstinputlisting[style=oscode,language=make,
  caption={\texttt{Makefile}: build and run using QEMU.},
  label={lst-makefile}]{../code/chapter1/Makefile}
\end{figure}

\section*{Assembly start-up code}

Execution begins at the symbol \texttt{\_start}.  
We disable all but one core and jump into C.

\begin{figure}[htb]
\centering
\lstinputlisting[style=oscode,language={[x86masm]Assembler},
  caption={\texttt{start.s}: minimal start-up.},
  label={lst-start-s}]{../code/chapter1/start.s}
\end{figure}

\paragraph{About the \texttt{mhartid} register.}
Each RISC-V core (hart) has a unique ID in the \texttt{mhartid} CSR.  
We use it to let only core 0 continue into C, keeping the others parked in an infinite loop.

\section*{C source}

The C portion writes characters to a memory-mapped UART.

\begin{figure}[htb]
\centering
\lstinputlisting[style=oscode,language=C,
  caption={\texttt{hello.c}: write “Hello, World” over the UART.},
  label={lst-hello-c}]{../code/chapter1/hello.c}
\end{figure}

\noindent
The UART lives at \texttt{0x10010000} in QEMU’s \texttt{sifive\_u} machine.  
We spin until the transmitter is free, then send one character at a time.

\section*{Linker script}

The linker script defines our memory map and entry point.

\begin{figure}[htb]
\centering
\lstinputlisting[style=oscode,language=C,
  caption={\texttt{hello.lds}: linker script.},
  label={lst-hello-lds}]{../code/chapter1/hello.lds}
\end{figure}

\noindent
The code is loaded at \texttt{0x80000000} in RAM.  
The \texttt{ENTRY(\_start)} directive tells the linker where execution begins.

\section*{Running it}

Build and run:
\begin{verbatim}
make qemu
\end{verbatim}

If all goes well, you’ll see:
\begin{verbatim}
Hello, World
\end{verbatim}

Congratulations—you have written a working (if tiny) operating system!

\section*{Projects}

\begin{enumerate}
  \item \textbf{Remove the first two assembly lines.} What happens?
  \item \textbf{Modify the message.} Try printing your name.
  \item \textbf{Add a newline.} Does \texttt{"\textbackslash n"} behave as expected?
  \item \textbf{Add another function.} Write \texttt{puthex(int x)} that prints a value in hex.
\end{enumerate}
