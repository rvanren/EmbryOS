\chapter{Hello World}

Before we dive into kernel code, let's set up a clean, reproducible environment.
This chapter will guide you through creating a Docker container that can build
and run our operating system, \textbf{EmbryOS}, on a RISC\textendash V
emulator.  By the end, we will make the machine print ``Hello~World'' using a
single UART register.

\section{Why Docker?}

Different computers have different toolchains and library versions.  Using a
container guarantees that everyone---on macOS, Windows, or Linux---is building
the same thing.  We will use Docker to install the RISC\textendash V compiler
and QEMU emulator inside a self-contained Ubuntu environment.

\section{Project Layout}

Each chapter comes with its own directory under \texttt{code/}:

\begin{verbatim}
code/
 +- chapter0/
 +- chapter1/
 |   +- Dockerfile
 |   +- Makefile
 |   +- main.c
 |   +- start.S
 |   \- linker.ld
 \- ...
\end{verbatim}

You can open these files in a simple text editor such as \texttt{nano} (already
included in the container) or your favorite local editor if you mount the
directory into Docker.

\input{chapter1/dockerfile}
\input{chapter1/makefile}
\input{chapter1/hello}
\input{chapter1/uart}
\input{chapter1/loader}

\section*{Projects}

Each chapter ends with a few short projects designed to encourage exploration.
These are not graded exercises but small experiments—things to try and observe
what happens.  Modify the code, rebuild, and run it again under QEMU to see how
EmbryOS behaves.

\begin{enumerate}
  \item \textbf{Disabling the \texttt{mhartid} check.}
  Open \texttt{hello.s} and remove the first two lines:
  \begin{lstlisting}[style=oscode,language={[x86masm]Assembler}]
  csrr a0, mhartid
  beq a0, x0, _end
  \end{lstlisting}
  Rebuild and run the program.
  \begin{itemize}
    \item What happens on your terminal?
    \item Why might the output look different or garbled?
    \item What does this tell you about how many cores QEMU is simulating?
  \end{itemize}
  This experiment reveals why the \texttt{mhartid} check was there: without it,
  every hardware thread (hart) runs the same code and all write to the UART at
  once.
\end{enumerate}

\bigskip
\noindent
Feel free to extend this experiment—try changing the number of simulated cores
in the Makefile’s QEMU command line (\texttt{-smp 2}) and observe the results.
In later chapters we’ll learn how to coordinate multiple cores properly using
synchronization and interrupts.
