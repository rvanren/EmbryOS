\section{The Code: Assembly and C}

Our ``Hello World'' kernel consists of two tiny source files: one in assembly
that sets up the machine and calls into C, and one in C that writes characters
to the UART device.  Together they form the simplest possible operating system.

\subsection{Assembly: Starting Up the Machine}

The RISC\textendash V processor begins execution at address zero in machine
mode.  The short assembly program in Listing~\ref{lst:hello_s} defines the entry
point \texttt{\_start}.  It disables the first core, initializes the stack
pointer, and then calls \texttt{main()} written in C.

\begin{figure}[H]
\centering
\begin{minipage}{0.9\textwidth}
\lstinputlisting[style=oscode,language={[x86masm]Assembler},caption={Startup assembly for EmbryOS},label={lst:hello_s}]{../code/chapter1/hello.s}
\end{minipage}
\end{figure}

A few details:

\begin{itemize}
  \item \texttt{csrr a0, mhartid} reads the hardware thread ID (``hart ID'') of
        the running core.
  \item Core~0 is disabled so that only the second core executes the program;
        this simplifies early testing.
  \item The instruction \texttt{li sp, 0x80400000} initializes the stack
        pointer to an arbitrary address in memory.
  \item Finally, \texttt{call main} jumps into the C function
        \texttt{main()}, after which control will not return.
\end{itemize}

This short sequence is all that’s needed to transition from the CPU’s reset
state into C code.
