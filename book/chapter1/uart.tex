\subsection{C: Talking to the UART}

Once the processor is running C code, we can access hardware devices directly
using \emph{memory-mapped I/O}.  The UART (serial port) is available at address
\texttt{0x10010000} on QEMUâ€™s \texttt{sifive\_u} machine.  Writing a character
to this address sends it to the terminal.

\begin{figure}[H]
\centering
\begin{minipage}{0.95\textwidth}
\lstinputlisting[style=oscode,language=C,caption={C code for printing ``Hello World'' through the UART},label={lst:ch1_hello_c}]{../code/chapter1/hello.c}
\end{minipage}
\end{figure}

Here, the compiler treats the \texttt{UART} pointer as a direct reference to a
hardware device.  The \texttt{putchar()} function busy-waits until the UART is
ready, then writes a single character.  \texttt{printf()} loops through a string
and sends each character one at a time.

\medskip
\noindent
When QEMU runs this program, each call to \texttt{putchar()} writes to the UART
register, which appears on your terminal.  The result is the familiar output:

\begin{lstlisting}
Hello World
\end{lstlisting}

\medskip
\noindent
This is a complete operating system in fewer than thirty lines of code: it
boots, runs C, communicates with hardware, and never returns.
